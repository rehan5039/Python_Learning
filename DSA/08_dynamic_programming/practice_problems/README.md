# Practice Problems - Dynamic Programming

This folder contains practice problems to reinforce your understanding of Dynamic Programming concepts. Each problem is designed to help you master different aspects of DP.

## Problem Sets

### Fundamentals
1. **Fibonacci Series** - Implement various approaches to calculate Fibonacci numbers
2. **Climbing Stairs** - Determine number of ways to climb stairs with 1 or 2 steps
3. **Min Cost Climbing Stairs** - Find minimum cost to reach the top of stairs
4. **House Robber** - Maximize stolen money without robbing adjacent houses

### String Algorithms
5. **Longest Palindromic Substring** - Find the longest palindrome in a string
6. **Regular Expression Matching** - Implement regex matching with '.' and '*'
7. **Wildcard Matching** - Implement pattern matching with '?' and '*'
8. **Distinct Subsequences** - Count distinct subsequences matching a target

### Knapsack Variants
9. **0/1 Knapsack** - Classic knapsack problem with limited item quantities
10. **Unbounded Knapsack** - Knapsack problem with unlimited item quantities
11. **Coin Change** - Find minimum coins or combinations for a target amount
12. **Rod Cutting** - Maximize profit by cutting a rod into pieces

### Sequence Problems
13. **Longest Common Subsequence** - Find longest common subsequence between strings
14. **Longest Increasing Subsequence** - Find longest increasing subsequence in array
15. **Edit Distance** - Calculate minimum operations to transform one string to another
16. **Matrix Chain Multiplication** - Find optimal way to multiply matrices

### Advanced Problems
17. **Maximum Subarray** - Find contiguous subarray with maximum sum (Kadane's algorithm)
18. **Palindrome Partitioning** - Find minimum cuts to partition string into palindromes
19. **Word Break** - Determine if string can be segmented into dictionary words
20. **Decode Ways** - Count number of ways to decode a string of digits

## Difficulty Levels

### Beginner (Problems 1-4)
- Focus on basic DP concepts
- Simple state definitions
- Direct recurrence relations
- Linear DP problems

### Intermediate (Problems 5-12)
- Multi-dimensional DP
- String manipulation with DP
- More complex state transitions
- Classic algorithmic problems

### Advanced (Problems 13-20)
- Optimization techniques
- State space reduction
- Complex problem decomposition
- Real-world applications

## Solution Approach

For each problem, follow these steps:

1. **Problem Understanding**
   - Identify what needs to be optimized
   - Determine constraints and inputs/outputs
   - Look for examples and edge cases

2. **Identify DP Properties**
   - Overlapping subproblems
   - Optimal substructure
   - State definition

3. **Define Recurrence Relation**
   - Base cases
   - Recursive formula
   - Memoization vs. Tabulation decision

4. **Implementation**
   - Choose appropriate data structures
   - Handle edge cases
   - Optimize space complexity if possible

5. **Testing**
   - Verify with provided examples
   - Test edge cases
   - Analyze time and space complexity

## Tips for Success

1. **Start Simple** - Begin with recursive solution, then add memoization
2. **Visualize** - Draw tables or diagrams to understand state transitions
3. **Practice Patterns** - Recognize common DP patterns (knapsack, LIS, etc.)
4. **Analyze Complexity** - Always determine time and space complexity
5. **Optimize** - Look for space optimization opportunities

## Solutions

Refer to [problems.py](problems.py) for complete solutions with explanations.